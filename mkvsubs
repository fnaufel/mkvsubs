#!/usr/bin/env raku
use v6.d;

sub MAIN($mkv-file, $language = '') {

    my $file = $mkv-file.IO.open;
    unless $file {
        put "ERROR: { $file.exception }";
        exit;
    }

    say "Reading file $mkv-file...";

    my $proc = run <mkvinfo>, "$mkv-file", :out, :err;
    my $lines = $proc.out.lines.join("\n");
    my $errors = $proc.err.slurp;

    if $errors {
        say $errors;
        exit;
    }

    # THE GRAMMAR!
    grammar mkvinfo {

        token TOP { <level0>+ }

        token level0 {
            <level0-header>
            [ <tracks-block> | <level1-other> ]*
        }

        token level0-header {
            \+      # initial + (no bar)
            ' '     # exactly one space
            \V+     # anything except vertical ws
            \v
        }

        token tracks-block {
            "|+ Tracks"
            \v
            <one-track>+
        }

        token one-track {
            "| + Track"
            \v
            <track-item>+ %% \v   # TODO: add code here to assemble track data
        }

        token track-item {
            \|
            '  ' ' '*  # Must have at least 2 spaces
            \+
            ' '
            <track-item-text>
        }

        token track-item-text {
            \V+
        }

        # Other level one items (or their descendants).
        token level1-other {
            \|      # initial bar
            ' '*    # zero (level 1) or more (other descendant levels) spaces
            \+      # plus sign
            ' '     # exactly one space
            \V+     # anything except vertical ws
            \n?     # newline is optional on last line
        }
    }

    # The actions
    class Actions {

        method TOP($/) {

            my @blocks = $/<level0>;
            my @tracks;

            for @blocks {
                if $_.made {
                    @tracks .= push: $_.made.Slip;
                }
            }

            make @tracks;

        }

        method level0($/) {

            make $/<tracks-block>.map(*.made).flat;

        }

        method tracks-block($/) {

            my @tracks = $/<one-track>;
            my @good-tracks = @tracks>>.made.grep: { .so };
            make @good-tracks;

        }

        method one-track($/) {

            my $track-no-regex = rx/
            ^
            Track\snumber\:\s
            \d+\s
            \(track\sID\sfor\smkvmerge\s\&\smkvextract\:\s
            (\d+)\)
            $
            /;

            my $track-type-regex = rx/ ^Track\stype\:\ssubtitles$ /;
            my $track-lang-regex = rx/ ^Language\:\s(\w+)$ /;
            my $track-name-regex = rx/ ^Name\:\s(.+)$ /;

            my %track;

            for $/<track-item> -> $item {

                my $line = $item<track-item-text>.Str;
                my $match-number = $line ~~ $track-no-regex;
                my $match-type = $line ~~ $track-type-regex;
                my $match-lang = $line ~~ $track-lang-regex;
                my $match-name = $line ~~ $track-name-regex;

                if $match-number {
                    %track.append: (number => ~$match-number[0]);
                }
                elsif $match-type {
                    %track.append: (type => 'subtitles');
                }
                elsif $match-lang {
                    %track.append: (lang => ~$match-lang[0]);
                }
                elsif $match-name {
                    %track.append: (name => ~$match-name[0]);
                }

            }

            if %track<type>:exists {
                # is subtitle track
                make %track;
            } else {
                # is not subtitle track
                make False;
            }

        }

    }

    my $parsed = mkvinfo.parse($lines, actions => Actions.new);
    say $parsed.made.raku;

#     TODO
#     If no language was asked, show menu and get choice.
#     Extract desired track.

}
